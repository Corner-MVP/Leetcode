# 207. 课程表

## 题目描述
你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1` 。

在选修某些课程之前需要一些先修课程。 先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [ai, bi]` ，表示如果要学习课程 $a_i$ 则 必须 先学习课程  $b_i$ 。

例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。
请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。

## 示例
### 示例 1
```
输入：numCourses = 2, prerequisites = [[1,0]]
输出：true
解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。
```

### 示例 2
```
输入：numCourses = 2, prerequisites = [[1,0],[0,1]]
输出：false
解释：总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。
```

### 提示
- $1 <= numCourses <= 10^5$
- `0 <= prerequisites.length <= 5000`
- `prerequisites[i].length == 2`
- $0 <= a_i, b_i < numCourses$
- `prerequisites[i]` 中的所有课程对 **互不相同**

## 思路

## 代码
### Python
```
from collections import defaultdict

class Solution:
    def canFinish(self, numCourses, prerequisites):
        relation = defaultdict(list)
        for group in prerequisites:
            child, parent = group[0], group[1]
            relation[parent].append(child)
        
        visit = [0 for i in range(numCourses)]
        
        def DFS(node):
            
            if visit[node] == 1: 
                return False
            if visit[node] == 2: 
                return True


            visit[node] = 1
            for nextNode in relation[node]:
                if not DFS(nextNode):
                    return False


            visit[node] = 2
            
            return True
        
        for course in range(numCourses):
            if not DFS(course):
                return False
        return True
```

### JavaScript
```
/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {boolean}
 */
 var canFinish = function(numCourses, prerequisites) {

    const relation = new Map()
    for (const group of prerequisites) {
      const child = group[0], parent = group[1]
      relation.get(parent) ? relation.get(parent).push(child) : relation.set(parent, [child])
    }

    const visited = new Array(numCourses).fill(0)

    const dfs = (node) => {

      if (visited[node] === 1) return false
      if (visited[node] === 2) return true
      
      visited[node] = 1
      if (relation.get(node)) {
        for (const nextNode of relation.get(node)) {
          if (!dfs(nextNode)) return false
        }
      }

      visited[node] = 2
      return true

    }

    for (let course = 0; course < numCourses; course++) {
      if (!dfs(course)) return false
    }
    return true

};
```

## 时间(空间)复杂度